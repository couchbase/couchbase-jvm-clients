/*
 * Copyright 2024 Couchbase, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.couchbase.columnar.client.java.sandbox;

import com.couchbase.client.core.annotation.Stability;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import static com.couchbase.client.core.util.CbCollections.listCopyOf;
import static com.couchbase.columnar.client.java.sandbox.KeyField.Type.AUTO_GENERATED_UUID;

@Stability.Volatile
public class PrimaryKey {
  private final List<KeyField> fields;

  /**
   * Convenience method that specifies an auto-generated primary key
   * for the given top-level field name.
   *
   * @param fieldPath The primary key field's path exactly as it should appear in a SQL statement;
   * caller is responsible for escaping, if necessary.
   */
  public static PrimaryKey ofAutoGenerated(String fieldPath) {
    return of(fieldPath, AUTO_GENERATED_UUID);
  }

  /**
   * Convenience method that specifies a primary key
   * (a key consisting of only one field).
   *
   * @param fieldPath The primary key field's path exactly as it should appear in a SQL statement;
   * caller is responsible for escaping, if necessary.
   * @param fieldType The primary key's field type
   */
  public static PrimaryKey of(
    String fieldPath,
    KeyField.Type fieldType
  ) {
    return of(new KeyField(fieldPath, fieldType));
  }

  /**
   * Specifies a primary or composite key, depending on the number of arguments.
   *
   * @param firstField at least one field is required
   * @param remainingFields optionally specify more fields to create a composite key
   * @throws IllegalArgumentException if multiple fields are specified and at least one is auto-generated.
   */
  public static PrimaryKey of(
    KeyField firstField,
    KeyField... remainingFields
  ) {
    List<KeyField> list = new ArrayList<>();
    list.add(firstField);
    list.addAll(Arrays.asList(remainingFields));
    return of(list);
  }

  /**
   * Specifies a primary or composite key, depending on the number of arguments.
   *
   * @throws IllegalArgumentException if no fields are specified, or
   * if multiple fields are specified and at least one is auto-generated.
   */
  public static PrimaryKey of(Iterable<KeyField> fields) {
    return new PrimaryKey(fields);
  }

  private PrimaryKey(Iterable<KeyField> fields) {
    this.fields = listCopyOf(fields);
    if (this.fields.isEmpty()) {
      throw new IllegalArgumentException("A key must have at least one field, but no fields were specified.");
    }
    if (this.fields.size() > 1 && this.fields.stream().anyMatch(it -> it.type() == AUTO_GENERATED_UUID)) {
      throw new IllegalArgumentException("A composite key must not have an auto-generated field, but got key: " + this.fields);
    }
  }

  public List<KeyField> fields() {
    return fields;
  }

  @Override
  public String toString() {
    return toSql();
  }

  public String toSql() {
    boolean auto = fields.stream().anyMatch(it -> it.type() == AUTO_GENERATED_UUID);
    if (auto) {
      return "PRIMARY KEY (" + fields.get(0).path() + ": UUID) AUTOGENERATED";
    }

    return "PRIMARY KEY (" +
      fields.stream()
        .map(KeyField::toSql)
        .collect(Collectors.joining(", ")) +
      ")";
  }
}
